# COP2 (VU) macro instruction set

define pcodeop BC2F;
define pcodeop BC2FL;
define pcodeop BC2T;
define pcodeop BC2TL;
define pcodeop CFC2;
define pcodeop CTC2;
define pcodeop QMFC2;
define pcodeop QMTC2;
define pcodeop VCALLMS;
define pcodeop VCALLMSR;

# COP2 floating point registers
define register offset=0x4100 size=16 [
    vf0     vf1     vf2     vf3
    vf4     vf5     vf6     vf7
    vf8     vf9     vf10    vf11
    vf12    vf13    vf14    vf15
    vf16    vf17    vf18    vf19
    vf20    vf21    vf22    vf23
    vf24    vf25    vf26    vf27
    vf28    vf29    vf30    vf31
];

define register offset=0x4100 size=4 [
    vf0x        vf0y        vf0z        vf0w
    vf1x        vf1y        vf1z        vf1w
    vf2x        vf2y        vf2z        vf2w
    vf3x        vf3y        vf3z        vf3w
    vf4x        vf4y        vf4z        vf4w
    vf5x        vf5y        vf5z        vf5w
    vf6x        vf6y        vf6z        vf6w
    vf7x        vf7y        vf7z        vf7w
    vf8x        vf8y        vf8z        vf8w
    vf9x        vf9y        vf9z        vf9w
    vf10x       vf10y       vf10z       vf10w
    vf11x       vf11y       vf11z       vf11w
    vf12x       vf12y       vf12z       vf12w
    vf13x       vf13y       vf13z       vf13w
    vf14x       vf14y       vf14z       vf14w
    vf15x       vf15y       vf15z       vf15w
    vf16x       vf16y       vf16z       vf16w
    vf17x       vf17y       vf17z       vf17w
    vf18x       vf18y       vf18z       vf18w
    vf19x       vf19y       vf19z       vf19w
    vf20x       vf20y       vf20z       vf20w
    vf21x       vf21y       vf21z       vf21w
    vf22x       vf22y       vf22z       vf22w
    vf23x       vf23y       vf23z       vf23w
    vf24x       vf24y       vf24z       vf24w
    vf25x       vf25y       vf25z       vf25w
    vf26x       vf26y       vf26z       vf26w
    vf27x       vf27y       vf27z       vf27w
    vf28x       vf28y       vf28z       vf28w
    vf29x       vf29y       vf29z       vf29w
    vf30x       vf30y       vf30z       vf30w
    vf31x       vf31y       vf31z       vf31w
];

define register offset=0x4200 size=2 [
     vi0  _ _ _  _ _ _ _
     vi1  _ _ _  _ _ _ _
     vi2  _ _ _  _ _ _ _
     vi3  _ _ _  _ _ _ _
     vi4  _ _ _  _ _ _ _
     vi5  _ _ _  _ _ _ _
     vi6  _ _ _  _ _ _ _
     vi7  _ _ _  _ _ _ _
     vi8  _ _ _  _ _ _ _
     vi9  _ _ _  _ _ _ _
     vi10 _ _ _  _ _ _ _
     vi11 _ _ _  _ _ _ _
     vi12 _ _ _  _ _ _ _
     vi13 _ _ _  _ _ _ _
     vi14 _ _ _  _ _ _ _
     vi15 _ _ _  _ _ _ _
];

#obtained from pcsx2 VU.h
define register offset=0x4300 size=4 [
    vuStatus_32 _ _ _
    vuMAC_32 _ _ _
    vuCF_32 _ _ _
    vuACCw vuACCz vuACCy vuACCx
    vuR_32 _ _ _
    vuI _ _ _
    Q _ _ _
    P _ _ _
    vf0_flag _ _ _
    _ _ _ _
    vuTCP_32 _ _ _
    vuCMSAR0_32 _ _ _
    vuFBRST _ _ _
    vpu_STAT _ _ _
    _ _ _ _
    vuCMSAR1_32 _ _ _
];

define register offset=0x4330 size=16 vuACC;

#define bitrange vuVBS0=vpu_STAT[0,1]
#                vuVDS0=vpu_STAT[1,1]
#                vuVTS0=vpu_STAT[2,1]
#                vuVFS0=vpu_STAT[3,1]
#                vuDIV0=vpu_STAT[5,1]
#                vuIBS0=vpu_STAT[7,1]
#                vuVBS1=vpu_STAT[8,1]
#                vuVDS1=vpu_STAT[9,1]
#                vuVTS1=vpu_STAT[10,1]
#                vuVFS1=vpu_STAT[11,1]
#                vuVGW1=vpu_STAT[12,1]
#                vuDIV1=vpu_STAT[13,1]
#                vuEFU1=vpu_STAT[14,1];

#define bitrange vuFB0=vuFBRST[0,1]
#                vuRS0=vuFBRST[1,1]
#                vuDE0=vuFBRST[2,1]
#                vuTE0=vuFBRST[3,1]
#                vuFB1=vuFBRST[8,1]
#                vuRS1=vuFBRST[9,1]
#                vuDE1=vuFBRST[10,1]
#                vuTE1=vuFBRST[11,1];

#define bitrange vuCMSAR0=vuCMSAR0_32[0,15];
#define bitrange vuCMSAR1=vuCMSAR1_32[0,15];

#define bitrange vuTCP=vuTCP_32[0,15];

#define bitrange vuCF=vuCF_32[0,23];

#define bitrange vuMAC=vuMAC_32[0,15]
#                vuZw=vuMAC_32[0,1]
#                vuZz=vuMAC_32[1,1]
#                vuZy=vuMAC_32[2,1]
#                vuZx=vuMAC_32[3,1]
#                vuSw=vuMAC_32[4,1]
#                vuSz=vuMAC_32[5,1]
#                vuSy=vuMAC_32[6,1]
#                vuSx=vuMAC_32[7,1]
#                vuUw=vuMAC_32[8,1]
#                vuUz=vuMAC_32[9,1]
#                vuUy=vuMAC_32[10,1]
#                vuUx=vuMAC_32[11,1]
#                vuOw=vuMAC_32[12,1]
#                vuOz=vuMAC_32[13,1]
#                vuOy=vuMAC_32[14,1]
#                vuOx=vuMAC_32[15,1];

#define bitrange vuStatus=vuStatus_32[0,11]
#                vuStatusZ=vuStatus_32[0,1]
#                vuStatusS=vuStatus_32[1,1]
#                vuStatusU=vuStatus_32[2,1]
#                vuStatusO=vuStatus_32[3,1]
#                vuStatusI=vuStatus_32[4,1]
#                vuStatusD=vuStatus_32[5,1]
#                vuStatusZS=vuStatus_32[6,1]
#                vuStatusSS=vuStatus_32[7,1]
#                vuStatusUS=vuStatus_32[8,1]
#                vuStatusOS=vuStatus_32[9,1]
#                vuStatusIS=vuStatus_32[10,1]
#                vuStatusDS=vuStatus_32[11,1];

#define bitrange vuR=vuR_32[0,23];

attach variables [ vuft vufd vufd_qmc2 vufs vuft_L vufd_L vufs_L ] [
    vf0     vf1     vf2     vf3
    vf4     vf5     vf6     vf7
    vf8     vf9     vf10    vf11
    vf12    vf13    vf14    vf15
    vf16    vf17    vf18    vf19
    vf20    vf21    vf22    vf23
    vf24    vf25    vf26    vf27
    vf28    vf29    vf30    vf31
];

attach variables [ vuit vuis vuid ] [
     vi0     vi1     vi2     vi3
     vi4     vi5     vi6     vi7
     vi8     vi9    vi10    vi11
    vi12    vi13    vi14    vi15
    _ _ _ _
    _ _ _ _
    _ _ _ _
    _ _ _ _
];

macro ssum(src, dest) {
    dest = (src[32,32] f* src[32,32]) f+ (src[64,32] f* src[64,32]) f+ (src[96,32] f* src[96,32]);
}

VI: immfloat is vucI_L=1 & immfloat {tmp:4 = float2float(immfloat:4); vuI = tmp; export tmp;}

vuinst: is prime=18 & vuco=1 & microMode=0 { export 0:1; }

with : microMode=1 & vuco=0 & vuco1=0 {
    with V1E: {
        : " [E]" is vucE=1 [cE=1; globalset(inst_next, cE);] { delayslot(2); return [0:4]; }
        : is vucE=0 {}
    }
    with V1M: {
        : " [M]" is vucM=1 [ cM = 1; globalset(inst_start, cM); ] {}
        : is vucM=0 {}
    }
    with V1D: {
        : " [D]" is vucD=1 { trap(); }
        : is vucD=0 {}
    }
    with V1T: {
        : " [T]" is vucT=1 { trap(); }
        : is vucT=0 {}
    }
}

with : microMode=1 & vuMicro=0 & cUpper=0 {
    with V1E_L: {
        :" [E]" is vucE_L=1 [cE=1; globalset(inst_next, cE);] { delayslot(1); return [0:4]; }
        : is vucE_L=0 {}
    }
    with V1M_L: {
        : " [M]" is vucM_L=1 [ cM = 1; globalset(inst_start, cM); ] {}
        : is vucM_L=0 {}
    }
    with V1D_L: {
        : " [D]" is vucD_L=1 { trap(); }
        : is vucD_L=0 {}
    }
    with V1T_L: {
        : " [T]" is vucT_L=1 { trap(); }
        : is vucT_L=0 {}
    }
}

VUFLAGS:^V1E^V1M^V1D^V1T is cUpper=1 & V1E & V1M & V1D & V1T [cUpper=0; globalset(inst_next, cUpper);] { build V1D; build V1T; }
VUFLAGS_L:^V1E_L^V1M_L^V1D_L^V1T_L is V1E_L & V1M_L & V1D_L & V1T_L { build V1D_L; build V1T_L; }

with VUIT: {
    :vuit is vuit { export vuit; }
    :vuit is vuit & vuit=0 { export 0:2; }
}
with VUIS: {
    :vuis is vuis { export vuis; }
    :vuis is vuis & vuis=0 { export 0:2; }
}
with VUID: {
    :vuid is vuid { export vuid; }
    :vuid is vuid & vuid=0 { export 0:2; }
}

VU_OFF_BASE_IT: vusimm11(VUIT) is vusimm11 & VUIT { tmp:4 = zext((VUIT + vusimm11))*16; export tmp; }
VU_OFF_BASE_IS: vusimm11(VUIS) is vusimm11 & VUIS { tmp:4 = zext((VUIS + vusimm11))*16; export tmp; }
